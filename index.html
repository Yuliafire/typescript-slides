<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>What is TypeScript</h1>
					<div>TypeScript, a superset of JavaScript developed by Microsoft,
						is a statically typed language that compiles to plain JavaScript.
						By introducing static typing, TypeScript enhances the development
						experience by detecting errors early in the development process and
						providing improved tooling support.</div>
				</section>
				<!-- <section>
					<h2>Why to use typescript?</h2>
					<h3>Part 1</h3>
					<div>
						<ul>
							<li>TypeScript's <strong>static typing</strong> feature enables early error detection and enhances
								code quality and maintainability.</li>
							<li>TypeScript offers <strong>superior tooling support</strong> with features like code
								navigation, intelligent code completion, and refactoring tools, improving developer
								productivity.</li>
							<li>
								TypeScript's support for <strong>object-oriented programming</strong> concepts
								facilitates the development of scalable and maintainable codebases.</li>
						</ul>
					</div>
				</section> -->

				<section>
					<h2>Why Use TypeScript?</h2>
					<h3>Part 1</h3>
					<div>
						<ul>
							<li>
								<strong>Catch errors early:</strong> TypeScript's static typing helps you spot mistakes while writing code, making your projects more reliable and easier to maintain.
							</li>
							<li>
								<strong>Boost productivity:</strong> With features like smart code navigation, auto-completion, and refactoring tools, TypeScript makes coding faster and more enjoyable.
							</li>
							<li>
								<strong>Write scalable code:</strong> TypeScript supports object-oriented programming, helping you build clean, organized, and scalable applications.
							</li>
						</ul>
					</div>
				</section>
				<section>
					<h2>Why to use typescript?</h2>
					<h3>Part 2</h3>
					<div>
						<ul>
							<li>
								TypeScript provides support for the latest ECMAScript features,
								enabling developers to leverage modern JavaScript syntax and features.</li>
							<li>TypeScript is fully compatible with existing JavaScript
								codebases, allowing for seamless integration and incremental adoption.</li>
						</ul>
					</div>
				</section>

				<section>
					<h2>Disadvantages of TypeScript over JavaScript</h2>
					<ul>
						<li>TypeScript's static typing feature introduces
							<em>a learning curve</em> for developers unfamiliar with static typing concepts.
						</li>
						<li>TypeScript requires a <em>compilation step</em> to convert
							TypeScript code to JavaScript, adding complexity to the build process.</li>
						<li>In smaller projects where the benefits of static typing are less
							pronounced, the additional overhead of TypeScript may outweigh its advantages.</li>
					</ul>
				</section>

				<section>
					<h2>Syntax Differences: JavaScript vs TypeScript</h2>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
					   let message = "Hello, World!";
					   // Type is determined at runtime
					   message = 42;
					   // No error, as JavaScript allows dynamic typing
					   console.log(message);
					</pre>

					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
					   let message: string = "Hello, World!";
					   // Type is explicitly defined
					   // message = 42;
					   // Error: Type 'number' is not assignable to type 'string'
					   console.log(message);
					</pre>
				</section>
	
				<section>
					<h2>Introduction to TypeScript Types</h2>
					<p>TypeScript extends JavaScript by adding a rich type system.
						While JavaScript primarily uses dynamic typing,
						TypeScript introduces additional types such as enums, tuples,
						and union/intersection types. These features enable developers
						to write safer and more maintainable code.</p>
				</section>
	
				<section>
					<h2>Primitive types</h2>
					<ul>
						<li>boolean</li>
						<li>number</li>
						<li>string</li>
						<li>bigint</li>
						<li>symbol</li>
						<li>undefined</li>
						<li>null</li>
					</ul>
				</section>
	
				<section>
					<h2>Special Types</h2>
						<li>any</li>
						<li>void</li>
						<li>never</li>
						<li>unknown</li>
				</section>
	
				<section>
					<h3>any</h3>
					<p>The <code>any</code> type disables type checking, allowing any value to be assigned. It should be avoided as it defeats the purpose of TypeScript's type safety.</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
				let value: any;
				value = "Hello"; // Valid
				value = 42;      // Valid
				value.toUpperCase(); // No compile-time error,
					 but runtime error if value is not a string
					</pre>
				</section>

				<section>
					<h3>unknown</h3>
					<p>The <code>unknown</code> type is a safer alternative to <code>any</code>. It requires type checking before usage.</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
				let value: unknown = "Hello";
				if (typeof value === "string") {
					console.log(value.toUpperCase()); // Safe
				}
					</pre>
				</section>

				<section>
					<h3>never</h3>
					<p>The <code>never</code> type represents values that never occur, such as functions that throw errors or infinite loops.</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
				function error(message: string): never {
					throw new Error(message);
				}
					</pre>
				</section>
				
				<section>
					<h3>void</h3>
					<p>The <code>void</code> type represents the absence of a value, typically used for functions that do not return anything.</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
				function logMessage(message: string): void {
					console.log(message);
				}
					</pre>
				</section>

				<section>
					<h2>Union Types</h2>
					<p>
						In TypeScript, a <strong>union type</strong> allows a value to be one of several specified types. It is useful when a variable can hold multiple types of values.
					</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
						// Union type example
						type StringOrNumber = string | number;
				
						let value: StringOrNumber;
				
						value = "Hello"; // Valid
						value = 42;      // Valid
						value = true;    // Invalid, not part of the union
					</pre>
				</section>
				
				<section>
					<h2>Intersection Types</h2>
					<p>
						An <strong>intersection type</strong> combines multiple types into one. A value of an intersection type must satisfy all the combined types simultaneously.
					</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
						// Intersection type example
						type Person = { name: string };
						type Employee = { jobTitle: string };
				
						type PersonEmployee = Person & Employee;
				
						const employee: PersonEmployee = {
							name: "Alice",
							jobTitle: "Developer"
						}; // Valid because it satisfies both `Person` and `Employee`
					</pre>
				</section>

				<section>
					<h2>Comparing Interfaces and Type Aliases</h2>
					<p>
						In TypeScript, both <code>interface</code> and <code>type</code> are used to define the structure of data. While they share similarities, they also have distinct features that make them suitable for different use cases. 
					</p>
					<p>
						This guide explores the key differences between interfaces and type aliases, including their ability to extend, merge, and represent various types.
					</p>
				</section>

				<section>
					<h2>Interfaces Can Be Extended</h2>
					<p>
						<strong>Interfaces</strong> in TypeScript can be extended using the <code>extends</code> keyword. This allows you to create new interfaces by building on existing ones.
					</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
						interface Person {
							name: string;
							age: number;
						}
				
						interface Employee extends Person {
							jobTitle: string;
						}
				
						const employee: Employee = {
							name: "Alice",
							age: 30,
							jobTitle: "Software Engineer"
						};
					</pre>
				</section>
				
				<section>
					<h2>Interfaces Support Declaration Merging</h2>
					<p>
						<strong>Interfaces</strong> can be reopened and merged. This means you can add new properties to an existing interface by declaring it again.
					</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
						interface Person {
							name: string;
						}

						// Declaration merging
						interface Person {
							middleName?: string;
						}

						const person: Person = {
							name: "Alice",
							middleName: "Marie"
						};
					</pre>
				</section>

				<section>
					<h2>Type Aliases Can Represent Primitives, Unions, Tuples, and More</h2>
					<p>
						<strong>Type aliases</strong> are more flexible than interfaces. They can represent primitives, unions, tuples, and other complex types.
					</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
						// Union type
						type StringOrNumber = string | number;
				
						const value: StringOrNumber = 42;
				
						// Tuple type
						type Point = [number, number];
				
						const point: Point = [10, 20];
					</pre>
				</section>
	
				<section>
					<h3>Union Types</h3>
					<p>Union types allow a variable to hold values of multiple types.</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
				let value: string | number;
				value = "Hello"; // Valid
				value = 42;      // Valid
				// value = true; // Error: Type 'boolean' is not assignable
								 to type 'string | number'
					</pre>
	
				</section>
	
				<section>
					<h2>Intersection Types</h2>
					<p>Intersection types combine multiple types into one. A variable must satisfy all the combined types.
					</p>
	
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
						interface Person {
							name: string;
						}

						interface Employee {
							employeeId: number;
						}

						type EmployeePerson = Person & Employee;
						const employee: EmployeePerson = {
							name: "Alice",
							employeeId: 123
						};
					</pre>
				</section>

				<section>
					<h2>Composite Types</h2>
					<p>Composite types allow grouping multiple values together.</p>
					<p>They include ARRAYS and TUPLES</p>
				</section>

				<section>
					<h3>Array</h3>
					<p>An array is a collection of elements of the same type.</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
					let numbers: number[] = [1, 2, 3, 4];
					numbers.push(5); // Valid
					numbers.push("hello"); // Error: Argument of type 'string'
					is not assignable to parameter of type 'number'
					</pre>
				</section>

				<section>
					<h3>Tuple</h3>
					<p>A tuple is a fixed-length array where each element can have a different type.</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
					let person: [string, number] = ["Alice", 25];
					// person = [25, "Alice"]; // Error: Type 'number' is not assignable to type 'string'
					</pre>
				</section>

				<section>
					<h2>Enum Types</h2>
					<p>Enums allow you to define a set of named constants.</p>
					<pre style="display: flex; justify-content: center; margin: 0; text-align: left;">
					enum Color {
						Red,
						Green,
						Blue
					}
					let favoriteColor: Color = Color.Green;
					console.log(favoriteColor); // Output: 1
					</pre>
				</section>

				<section>
				  <h2>Summary</h2>
				  <p>TypeScript offers several advantages over JS:</p>
				<ul>
				   <li><strong>Type Safety:</strong> Helps catch errors at compile time, reducing runtime bugs.</li>
					<li><strong>Improved Code Readability:</strong> Explicit types make the code easier to understand and maintain.</li>
					<li><strong>Enhanced Tooling:</strong> Provides better autocompletion, refactoring, and debugging support in IDEs.</li>
					<li><strong>Scalability:</strong> Facilitates large-scale application development with features like interfaces and type annotations.</li>
					<li><strong>Modern JavaScript Features:</strong> Supports ES6+ features and compiles to plain JavaScript for compatibility.</li>
				 </ul>
			   </section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
